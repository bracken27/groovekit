// Note: Junie (JetBrains AI) contributed code to this file on 2025-09-24.
#include "TrackEditView.h"
#include "../../AppEngine/AppEngine.h"
#include "PopupWindows/OutputDevice/OutputDeviceWindow.h"

TrackEditView::TrackEditView (AppEngine& engine)
{
    appEngine = std::shared_ptr<AppEngine> (&engine, [] (AppEngine*) {});
    trackList = std::make_unique<TrackListComponent> (appEngine);

    trackList->setPixelsPerSecond (pixelsPerSecond);
    trackList->setViewStart (viewStart);

    viewport.setScrollBarsShown (true, false); // vertical only
    viewport.setViewedComponent (trackList.get(), false);

    setupButtons();
    addAndMakeVisible (viewport);

    // MIDI keyboard setup
    midiKeyboardState.addListener (this);    // listen for note on/off so we can route to the selected track

    setWantsKeyboardFocus (true);
}

TrackEditView::~TrackEditView()
{
    // [Generated by Junie] Remove our MidiKeyboardState listener when the view is destroyed.
    midiKeyboardState.removeListener (this);
}

void TrackEditView::paint (juce::Graphics& g)
{
    g.fillAll (juce::Colours::black);
    g.setColour (juce::Colours::white);
    g.setFont (20.0f);
    g.drawText ("TrackView", getLocalBounds(), juce::Justification::centred, true);
}

void TrackEditView::resized()
{
    auto r = getLocalBounds();
    const int w = r.getWidth() / 7;
    auto topR = r.removeFromTop (30);

    backButton.setBounds (topR.removeFromLeft (w).reduced (2));
    //newEditButton.setBounds (topR.removeFromLeft (w).reduced (2));
    //openEditButton.setBounds (topR.removeFromLeft (w).reduced (2));
    playPauseButton.setBounds (topR.removeFromLeft (w).reduced (2));
    stopButton.setBounds (topR.removeFromLeft (w).reduced (2));
    recordButton.setBounds (topR.removeFromLeft (w).reduced (2));
    newTrackButton.setBounds (topR.removeFromLeft (w).reduced (2));
    outputButton.setBounds (topR.removeFromLeft (w).reduced (2));
    mixViewButton.setBounds (topR.removeFromLeft (w).reduced (2));

    viewport.setBounds (r);
}

bool TrackEditView::keyPressed(const juce::KeyPress &key_press) {
    // The note keys are being handled by keyStateChanged, so we'll just say that the event is consumed
    if (noteKeys.contains ( key_press.getKeyCode()))
        return true;

    if (key_press == juce::KeyPress::spaceKey)
    {
        // Spacebar toggles transport
        if (appEngine->isPlaying())
        {
            appEngine->stop();
        }
       else
       {
           appEngine->play();
       }
        return true;
    }

    // [Generated by Junie] Z/X change the base octave for QWERTY-to-MIDI mapping on the on-screen keyboard
    if (key_press.isKeyCode ('Z'))
    {
        keyboardBaseOctave = juce::jlimit (0, 10, keyboardBaseOctave - 1);
        // midiKeyboard->setKeyPressBaseOctave (keyboardBaseOctave);
        midiKeyboardState.allNotesOff (1); // Turn off all Midi notes that may be held down
        return true;
    }
    if (key_press.isKeyCode ('X'))
    {
        keyboardBaseOctave = juce::jlimit (0, 10, keyboardBaseOctave + 1);
        // midiKeyboard->setKeyPressBaseOctave (keyboardBaseOctave);
        midiKeyboardState.allNotesOff (1); // Turn off all Midi notes that may be held down
        return true;
    }

    // This is the top level of our application, so if the key press has not been consumed,
    // it is not an implemented key command in GrooveKit
    return true;
}

bool TrackEditView::keyStateChanged (bool isKeyDown)
{
    int noteNumber = keyboardBaseOctave * 12; // Starts at the C of whatever octave is set
    for (const char key : noteKeys)
    {
        if (isKeyDown)
        {
            if (juce::KeyPress::isKeyCurrentlyDown (key)
                && !midiKeyboardState.isNoteOn (1, noteNumber))
            {
                midiKeyboardState.noteOn (1, noteNumber, 0.5f);
                return true;
            }
        }
        else if (!juce::KeyPress::isKeyCurrentlyDown (key)
                 && midiKeyboardState.isNoteOn (1, noteNumber))
        {
            midiKeyboardState.noteOff (1, noteNumber, 0.5f);
            return true;
        }
        noteNumber++;
    }

    return false;
}

void TrackEditView::setupButtons()
{
    newTrackButton.onClick = [this] {
        juce::PopupMenu m;
        m.addItem (1, "Instrument (FourOsc)");
        m.addItem (2, "Drum (Sampler)");

        m.showMenuAsync (juce::PopupMenu::Options(), [this] (int choice) {
            if (!trackList || choice == 0)
                return;

            int index = -1;
            if (choice == 1)
                index = appEngine->addInstrumentTrack();
            else if (choice == 2)
                index = appEngine->addDrumTrack();
            DBG ("[TrackEditView] now " << appEngine->getNumTracks() << " tracks"); // insert here
            if (index >= 0)
            {
                trackList->addNewTrack (index);
                trackList->setPixelsPerSecond (pixelsPerSecond);
                trackList->setViewStart (viewStart);
            }
        });
    };

    playPauseButton.onClick = [this] {
        appEngine->play();
    };

    stopButton.onClick = [this] { appEngine->stop(); };

    addAndMakeVisible (newEditButton);
    addAndMakeVisible (playPauseButton);
    addAndMakeVisible (stopButton);
    addAndMakeVisible (recordButton);
    addAndMakeVisible (openEditButton);
    addAndMakeVisible (newTrackButton);
    addAndMakeVisible ((outputButton));

    outputButton.onClick = [this] {
        auto* content = new OutputDeviceWindow (*appEngine);

        content->setSize (360, 140);

        auto screenBounds = outputButton.getScreenBounds();
        juce::CallOutBox::launchAsynchronously (std::unique_ptr<Component> (content), screenBounds, nullptr);
    };

    addAndMakeVisible (mixViewButton);
    mixViewButton.onClick = [this] { if (onOpenMix) onOpenMix(); };

    addAndMakeVisible (backButton);
    backButton.onClick = [this] {
        if (onBack)
            onBack();
    };
}

void TrackEditView::handleNoteOn (juce::MidiKeyboardState*, int midiChannel, int midiNoteNumber, float velocity)
{
    // [Generated by Junie] Translate MidiKeyboardState events into JUCE MidiMessages and forward them to the selected track
    const int ch = (midiChannel <= 0 ? 1 : midiChannel);
    const juce::uint8 vel = (juce::uint8) juce::jlimit(0, 127, juce::roundToInt(velocity * 127.0f));
    juce::MidiMessage on = juce::MidiMessage::noteOn(ch, midiNoteNumber, vel);
    injectNoteMessage(on);
}

void TrackEditView::handleNoteOff (juce::MidiKeyboardState*, int midiChannel, int midiNoteNumber, float /*velocity*/)
{
    // [Generated by Junie] Corresponding note-off routed to the engine
    const int ch = (midiChannel <= 0 ? 1 : midiChannel);
    juce::MidiMessage off = juce::MidiMessage::noteOff (ch, midiNoteNumber);
    injectNoteMessage (off);
}

void TrackEditView::injectNoteMessage (const juce::MidiMessage& msg)
{
    // [Generated by Junie] Send the live MIDI message to the currently selected track so its instrument plays immediately.
    if (! appEngine)
        return;

    int idx = 0;
    if (trackList)
        idx = trackList->getSelectedTrackIndex();

    te::AudioTrack* track = appEngine->getTrackManager().getTrack (idx);
    if (track == nullptr)
        return;

    // [Generated by Junie] Ensure the Tracktion Edit has an allocated playback context before injecting live MIDI
    track->edit.getTransport().ensureContextAllocated();

    // [Generated by Junie] Use a fixed MPESourceID for live input; this keeps voices grouped if using MPE instruments
    const te::MPESourceID source ((juce::uint8) 2);
    track->injectLiveMidiMessage (te::MidiMessageWithSource (msg, source));
}

