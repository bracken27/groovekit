// Note: Junie (JetBrains AI) contributed code to this file on 2025-09-24.
#include "TrackEditView.h"
#include "../../AppEngine/AppEngine.h"
#include "PopupWindows/OutputDevice/OutputDeviceWindow.h"

// Helper for styling the menu buttons
void styleMenuButton (juce::TextButton& button)
{
    button.setColour (juce::TextButton::buttonColourId, juce::Colour (0x00000000));
    button.setColour (juce::TextButton::textColourOffId, juce::Colours::lightgrey);
    button.setColour (juce::TextButton::textColourOnId, juce::Colours::white);
}

TrackEditView::TrackEditView (AppEngine& engine)
{
    appEngine = std::shared_ptr<AppEngine> (&engine, [] (AppEngine*) {});

   #if JUCE_MAC
    // Use native macOS global menu bar
    juce::MenuBarModel::setMacMainMenu (this);
   #else
    menuBar = std::make_unique<juce::MenuBarComponent> (this);
    addAndMakeVisible (menuBar.get());
   #endif

    trackList = std::make_unique<TrackListComponent> (appEngine);

    trackList->setPixelsPerSecond (pixelsPerSecond);
    trackList->setViewStart (viewStart);

    viewport.setScrollBarsShown (true, false); // vertical only
    viewport.setViewedComponent (trackList.get(), false);

    trackList->rebuildFromEngine();

    appEngine->onEditLoaded = [this] {
        trackList = std::make_unique<TrackListComponent> (appEngine);
        trackList->setPixelsPerSecond (pixelsPerSecond);
        trackList->setViewStart (viewStart);

        viewport.setViewedComponent (trackList.get(), false);
        trackList->rebuildFromEngine();

        repaint();
    };

    setupButtons();

    // Initialize and hide the piano roll editor
    pianoRoll = std::make_unique<PianoRollEditor>(*appEngine, -1);
    addAndMakeVisible(pianoRoll.get());
    pianoRoll->setVisible(false);

    // Split the view vertically
    verticalLayout.setItemLayout(0, -0.45, -0.85, -0.6); // Track list takes 70%
    verticalLayout.setItemLayout(1, 5, 5, 5);          // 5-pixel splitter
    verticalLayout.setItemLayout(2, -0.15, -0.55, -0.4); // Piano roll takes 30%

    // Create and add resizer bar (index 1 in components array)
    resizerBar = std::make_unique<PianoRollResizerBar>(&verticalLayout, 1, false);
    addAndMakeVisible(resizerBar.get());

    addAndMakeVisible (viewport);

    // MIDI keyboard setup
    // [Generated by Junie] Create an on-screen piano keyboard that can also map the computer (QWERTY) keys to notes.
    // We pass it a shared MidiKeyboardState which will notify us of note on/off events.
    midiKeyboard = std::make_unique<juce::MidiKeyboardComponent> (midiKeyboardState, juce::MidiKeyboardComponent::horizontalKeyboard);
    midiKeyboard->setWantsKeyboardFocus (true);    // allows direct QWERTY input when the keyboard has focus
    midiKeyboard->setAvailableRange (36, 84);      // show a sensible note range: C2..C6
    midiKeyboard->setKeyPressBaseOctave (keyboardBaseOctave); // initial base octave for QWERTY mapping
    addAndMakeVisible (*midiKeyboard);
    midiKeyboardState.addListener (this);          // listen for note on/off so we can route to the selected track

    setWantsKeyboardFocus (true);
    addKeyListener (this);
}

TrackEditView::~TrackEditView()
{
    // [Generated by Junie] Remove our MidiKeyboardState listener when the view is destroyed.
    midiKeyboardState.removeListener (this);
}
TrackEditView::~TrackEditView()
{
   #if JUCE_MAC
    // Clear the native macOS menu bar to avoid assertions during shutdown
    juce::MenuBarModel::setMacMainMenu (nullptr);
   #endif
}

void TrackEditView::paint (juce::Graphics& g)
{
    const auto topBarBounds = getLocalBounds().removeFromTop (40);
    g.setColour (juce::Colour (0xFF212529)); // Even darker for top bar
    g.fillRect (topBarBounds);
    g.setColour (juce::Colours::black.withAlpha (0.2f));
    g.drawHorizontalLine (topBarBounds.getBottom(), 0.0f, static_cast<float> (getWidth()));
}

void TrackEditView::resized()
{
    auto r = getLocalBounds();
    const auto topBar = r.removeFromTop (40);
    viewport.setBounds (r);

    auto topBarContent = topBar.reduced (10, 0);

    // --- Menu ---
    if (menuBar)
        menuBar->setBounds (topBarContent.removeFromLeft (200));

    // --- Right side: Switch ---
    const auto switchArea = topBarContent.removeFromRight (50);
    switchButton.setBounds (switchArea);

    // --- Center: Transport ---
    auto centerArea = topBarContent;
    bpmLabel.setBounds (centerArea.removeFromLeft (80));
    clickLabel.setBounds (centerArea.removeFromLeft (50));

    constexpr int buttonSize = 20;
    constexpr int buttonGap = 10;
    constexpr int transportWidth = (buttonSize * 3) + (buttonGap * 2);
    auto transportBounds = centerArea.withSizeKeepingCentre (transportWidth, buttonSize);
    stopButton.setBounds (transportBounds.removeFromLeft (buttonSize));
    transportBounds.removeFromLeft (buttonGap);
    playButton.setBounds (transportBounds.removeFromLeft (buttonSize));
    transportBounds.removeFromLeft (buttonGap);
    recordButton.setBounds (transportBounds.removeFromLeft (buttonSize));

    // Content area below top bar
    // If the piano roll is hidden, just fill with the viewport and hide the resizer
    if (!pianoRoll || !pianoRoll->isVisible())
    {
        viewport.setBounds(r);
        if (resizerBar)
            resizerBar->setVisible(false);
        return;
    }

    // Piano roll is visible: use the stretchable layout to split vertically
    if (resizerBar)
        resizerBar->setVisible(true);

    juce::Component* comps[] = { &viewport, resizerBar.get(), pianoRoll.get() };
    verticalLayout.layOutComponents(comps, (int)std::size(comps), r.getX(), r.getY(), r.getWidth(), r.getHeight(), true, true);

    // Ensure the resizer and piano roll are on top of the viewport
    resizerBar->toFront(false);
    pianoRoll->toFront(false);
}

bool TrackEditView::keyPressed(const juce::KeyPress &key_press, juce::Component *) {
    if (key_press == juce::KeyPress::spaceKey)
    {
        if (appEngine->isPlaying())
        {
            appEngine->stop();
        }
       else
       {
           appEngine->play();
       }
        return true;
    }
    return false;
}

bool TrackEditView::keyPressed(const juce::KeyPress &key_press, juce::Component *) {
    if (key_press == juce::KeyPress::spaceKey)
    {
        // Spacebar toggles transport
        if (appEngine->isPlaying())
        {
            appEngine->stop();
        }
       else
       {
           appEngine->play();
       }
        return true;
    }

    // [Generated by Junie] Z/X change the base octave for QWERTY-to-MIDI mapping on the on-screen keyboard
    if (midiKeyboard != nullptr)
    {
        const juce::juce_wchar ch = key_press.getTextCharacter();
        if (ch == 'z' || ch == 'Z')
        {
            keyboardBaseOctave = juce::jlimit (0, 10, keyboardBaseOctave - 1);
            midiKeyboard->setKeyPressBaseOctave (keyboardBaseOctave);
            return true;
        }
        if (ch == 'x' || ch == 'X')
        {
            keyboardBaseOctave = juce::jlimit (0, 10, keyboardBaseOctave + 1);
            midiKeyboard->setKeyPressBaseOctave (keyboardBaseOctave);
            return true;
        }
    }

    // [Generated by Junie] Forward other keys to the MIDI keyboard so QWERTY can play notes without the keyboard having focus.
    // MidiKeyboardComponent handles the mapping of letter keys to MIDI notes and updates midiKeyboardState,
    // which will trigger our handleNoteOn/Off callbacks below.
    if (midiKeyboard && midiKeyboard->keyPressed (key_press))
        return true;

    return false;
}

void TrackEditView::setupButtons()
{
    // --- Left Controls ---
    addAndMakeVisible (bpmLabel);
    bpmLabel.setText ("BPM 120", juce::dontSendNotification);
    bpmLabel.setColour (juce::Label::textColourId, juce::Colours::lightgrey);
    bpmLabel.setJustificationType (juce::Justification::centred);

    addAndMakeVisible (clickLabel);
    clickLabel.setText ("Click", juce::dontSendNotification);
    clickLabel.setColour (juce::Label::textColourId, juce::Colours::lightgrey);
    clickLabel.setJustificationType (juce::Justification::centred);

    // --- Transport Buttons ---
    {
        juce::Path stopShape;
        stopShape.addRectangle (0.0f, 0.0f, 1.0f, 1.0f);
        stopButton.setShape (stopShape, true, true, false);
        stopButton.setColours (juce::Colours::lightgrey, juce::Colours::white, juce::Colours::darkgrey);
        stopButton.onClick = [this] { appEngine->stop(); };
        addAndMakeVisible (stopButton);

        juce::Path playShape;
        playShape.addTriangle (0.0f, 0.0f, 1.0f, 0.5f, 0.0f, 1.0f);
        playButton.setShape (playShape, true, true, false);
        playButton.setColours (juce::Colours::lightgrey, juce::Colours::white, juce::Colours::darkgrey);
        playButton.onClick = [this] { appEngine->play(); };
        addAndMakeVisible (playButton);

        juce::Path recordShape;
        recordShape.addEllipse (0.0f, 0.0f, 1.0f, 1.0f);
        recordButton.setShape (recordShape, true, true, false);
        recordButton.setColours (juce::Colours::red, juce::Colours::lightcoral, juce::Colours::maroon);
        addAndMakeVisible (recordButton);
    }

    // --- Right Switch ---
    addAndMakeVisible (switchButton);
    styleMenuButton (switchButton);
    switchButton.onClick = [this] { if (onOpenMix) onOpenMix(); };
}

juce::StringArray TrackEditView::getMenuBarNames()
{
    return { "File", "View", "Track", "Help" };
}

juce::PopupMenu TrackEditView::getMenuForIndex (const int topLevelMenuIndex, const juce::String&)
{
    juce::PopupMenu menu;
    enum MenuIDs {
        OpenMixer = 1002,
        ShowOutputSettings = 1003,
        NewEdit = 2001,
        OpenEdit = 2002,
        SaveEdit = 2003,
        SaveEditAs = 2004,
        NewInstrumentTrack = 3001,
        NewDrumTrack = 3002
    };

    if (topLevelMenuIndex == 0) // File
    {
        menu.addItem (NewEdit, "New Edit");
        menu.addItem (OpenEdit, "Open Edit...");
        menu.addSeparator();
        menu.addItem (SaveEdit, "Save Edit");
        menu.addItem (SaveEditAs, "Save Edit As...");
        menu.addSeparator();
        menu.addItem (ShowOutputSettings, "Output Device Settings...");
    }
    else if (topLevelMenuIndex == 1) // View
    {
        menu.addItem (OpenMixer, "Mix View");
    }
    else if (topLevelMenuIndex == 2) // Track
    {
        menu.addItem (NewInstrumentTrack, "New Instrument Track");
        menu.addItem (NewDrumTrack, "New Drum Track");
    }
    return menu;
}

void TrackEditView::menuItemSelected (const int menuItemID, int)
{
    enum MenuIDs {
        OpenMixer = 1002,
        ShowOutputSettings = 1003,
        NewEdit = 2001,
        OpenEdit = 2002,
        SaveEdit = 2003,
        SaveEditAs = 2004,
        NewInstrumentTrack = 3001,
        NewDrumTrack = 3002
    };

    switch (menuItemID)
    {
        case NewInstrumentTrack:
        case NewDrumTrack:
        {
            if (!trackList)
                return;
            const int index = (menuItemID == NewInstrumentTrack) ? appEngine->addInstrumentTrack() : appEngine->addDrumTrack();
            trackList->addNewTrack (index);
            trackList->setPixelsPerSecond (pixelsPerSecond);
            trackList->setViewStart (viewStart);
            break;
        }
        case OpenMixer:
            if (onOpenMix)
                onOpenMix();
            break;
        case ShowOutputSettings:
            showOutputDeviceSettings(); // TODO : fix positioning
            break;
        case NewEdit:
            showNewEditMenu();
            break;
        case OpenEdit:
            showOpenEditMenu();
            break;
        case SaveEdit:
            appEngine->saveEdit();
            break;
        case SaveEditAs:
            appEngine->saveEditAsAsync();
            break;
        default:
            break;
    }
}

void TrackEditView::showOutputDeviceSettings() const
{
    auto* content = new OutputDeviceWindow (*appEngine);

    content->setSize (360, 140);

    juce::Rectangle<int> screenBounds;
#if JUCE_MAC
    screenBounds = juce::Desktop::getInstance().getDisplays().getPrimaryDisplay()->userArea;
    screenBounds = screenBounds.withHeight (25); // Approx height of mac menu bar
#else
    if (menuBar)
        screenBounds = menuBar->getScreenBounds();
#endif
    juce::CallOutBox::launchAsynchronously (std::unique_ptr<Component> (content), screenBounds, nullptr);
}

void TrackEditView::showNewEditMenu() const
{
    if (appEngine->isDirty())
    {
        const auto opts = juce::MessageBoxOptions()
                        .withIconType (juce::MessageBoxIconType::WarningIcon)
                        .withTitle ("Save changes?")
                        .withMessage ("You have unsaved changes.")
                        .withButton ("Save")
                        .withButton ("Discard")
                        .withButton ("Cancel");

        juce::AlertWindow::showAsync (opts, [this] (const int r) {
            if (r == 1)
            { // Save
                const bool hasPath =
                    appEngine->getCurrentEditFile().getFullPathName().isNotEmpty();
                if (hasPath)
                {
                    if (appEngine->saveEdit())
                        appEngine->newUntitledEdit();
                }
                else
                {
                    appEngine->saveEditAsAsync ([this] (const bool ok) {
                        if (ok)
                            appEngine->newUntitledEdit();
                    });
                }
            }
            else if (r == 2)
            { // Discard
                appEngine->newUntitledEdit();
            }
        });
    }
    else
    {
        appEngine->newUntitledEdit();
    }
}

void TrackEditView::showOpenEditMenu() const
{
    if (!appEngine->isDirty())
    {
        appEngine->openEditAsync();
        return;
    }

    const auto opts = juce::MessageBoxOptions()
                          .withIconType (juce::MessageBoxIconType::WarningIcon)
                          .withTitle ("Save changes?")
                          .withMessage ("You have unsaved changes.")
                          .withButton ("Save")
                          .withButton ("Discard")
                          .withButton ("Cancel");

    juce::AlertWindow::showAsync (opts, [this] (const int result) {
        if (result == 1) // Save
        {
            if (appEngine->getCurrentEditFile().getFullPathName().isNotEmpty())
            {
                if (appEngine->saveEdit())
                    appEngine->openEditAsync();
            }
            else
            {
                appEngine->saveEditAsAsync ([this] (const bool ok) {
                    if (ok)
                        appEngine->openEditAsync();
                });
            }
        }
        else if (result == 2) // Discard
        {
            appEngine->openEditAsync();
        }
    });
}

void TrackEditView::showPianoRoll(int trackIndex)
{
    if (pianoRollTrackIndex != trackIndex)
    {
        pianoRollTrackIndex = trackIndex;
        pianoRoll = std::make_unique<PianoRollEditor> (*appEngine, trackIndex);
        addAndMakeVisible (pianoRoll.get());
    }
    pianoRoll->setVisible (true);
    resized();
}

void TrackEditView::hidePianoRoll()
{
    pianoRoll->setVisible (false);
    pianoRollTrackIndex = -1;
    resized();
}

int TrackEditView::getPianoRollIndex() const
{
    return pianoRollTrackIndex;
}

void TrackEditView::handleNoteOn (juce::MidiKeyboardState*, int midiChannel, int midiNoteNumber, float velocity)
{
    // [Generated by Junie] Translate MidiKeyboardState events into JUCE MidiMessages and forward them to the selected track
    const int ch = (midiChannel <= 0 ? 1 : midiChannel);
    const juce::uint8 vel = (juce::uint8) juce::jlimit(1, 127, juce::roundToInt(velocity * 127.0f));
    juce::MidiMessage on = juce::MidiMessage::noteOn(ch, midiNoteNumber, vel);
    injectNoteMessage(on);
}

void TrackEditView::handleNoteOff (juce::MidiKeyboardState*, int midiChannel, int midiNoteNumber, float /*velocity*/)
{
    // [Generated by Junie] Corresponding note-off routed to the engine
    const int ch = (midiChannel <= 0 ? 1 : midiChannel);
    juce::MidiMessage off = juce::MidiMessage::noteOff (ch, midiNoteNumber);
    injectNoteMessage (off);
}

void TrackEditView::injectNoteMessage (const juce::MidiMessage& msg)
{
    // [Generated by Junie] Send the live MIDI message to the currently selected track so its instrument plays immediately.
    if (! appEngine)
        return;

    int idx = 0;
    if (trackList)
        idx = trackList->getSelectedTrackIndex();

    te::AudioTrack* track = appEngine->getTrackManager().getTrack (idx);
    if (track == nullptr)
        return;

    // [Generated by Junie] Ensure the Tracktion Edit has an allocated playback context before injecting live MIDI
    track->edit.getTransport().ensureContextAllocated();

    // [Generated by Junie] Use a fixed MPESourceID for live input; this keeps voices grouped if using MPE instruments
    const te::MPESourceID source ((juce::uint8) 2);
    track->injectLiveMidiMessage (te::MidiMessageWithSource (msg, source));
}

void TrackEditView::PianoRollResizerBar::hasBeenMoved()
{
    // DBG("X: " << this->getX() << " Y: " << this->getY());
    resized();
}

void TrackEditView::PianoRollResizerBar::mouseDrag (const juce::MouseEvent& event)
{
    // DBG("X: " << this->getX() << " Y: " << this->getY());
    // this->setTopLeftPosition (this->getX(), event.getPosition().getY());
    hasBeenMoved();
}

 TrackEditView::PianoRollResizerBar::PianoRollResizerBar (juce::StretchableLayoutManager* layoutToUse, int itemIndexInLayout, bool isBarVertical) : StretchableLayoutResizerBar(layoutToUse, itemIndexInLayout, isBarVertical)
{
}

TrackEditView::PianoRollResizerBar::~PianoRollResizerBar()
= default;
