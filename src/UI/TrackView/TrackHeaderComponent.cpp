// [Generated by Junie] Contributor Note:
// The following file contains code contributions by Junie to enable in-place editing of the track label.
#include "TrackHeaderComponent.h"

TrackHeaderComponent::TrackHeaderComponent()
{
    addAndMakeVisible (instrumentButton);
    addAndMakeVisible (settingsButton);
    addAndMakeVisible (trackNameLabel);
    addAndMakeVisible (muteTrackButton);
    addAndMakeVisible (soloTrackButton);
    addAndMakeVisible (recordArmButton);
    instrumentButton.onClick = [this]() {
        listeners.call ([] (Listener& l) { l.onInstrumentClicked(); });
    };

    settingsButton.onClick = [this]() {
        listeners.call ([] (Listener& l) { l.onSettingsClicked(); });
    };

    muteTrackButton.setClickingTogglesState (true);
    muteTrackButton.setColour (juce::TextButton::buttonOnColourId, juce::Colours::red);
    muteTrackButton.setColour (juce::TextButton::buttonColourId, juce::Colours::darkgrey);
    muteTrackButton.setColour (juce::TextButton::textColourOnId, juce::Colours::white);
    muteTrackButton.setColour (juce::TextButton::textColourOffId, juce::Colours::white);
    muteTrackButton.onClick = [this]() {
        const bool nowMuted = muteTrackButton.getToggleState();
        listeners.call ([&] (Listener& l) { l.onMuteToggled (nowMuted); });
    };

    soloTrackButton.setClickingTogglesState (true);
    soloTrackButton.setColour (juce::TextButton::buttonOnColourId, juce::Colours::yellow);
    soloTrackButton.setColour (juce::TextButton::buttonColourId, juce::Colours::darkgrey);
    soloTrackButton.setColour (juce::TextButton::textColourOnId, juce::Colours::black);
    soloTrackButton.setColour (juce::TextButton::textColourOffId, juce::Colours::white);
    soloTrackButton.onClick = [this] {
        const bool nowSolo = soloTrackButton.getToggleState();
        listeners.call ([&] (Listener& l) { l.onSoloToggled (nowSolo); });
    };

    recordArmButton.setClickingTogglesState (true);
    recordArmButton.setColour (juce::TextButton::buttonOnColourId, juce::Colours::darkred);
    recordArmButton.setColour (juce::TextButton::buttonColourId, juce::Colours::darkgrey);
    recordArmButton.setColour (juce::TextButton::textColourOnId, juce::Colours::black);
    recordArmButton.setColour (juce::TextButton::textColourOffId, juce::Colours::white);
    recordArmButton.onClick = [this] {
        const bool nowArmed = recordArmButton.getToggleState();
        listeners.call ([&] (Listener& l) { l.onRecordArmToggled (nowArmed); });
    };

    trackNameLabel.setFont (juce::Font (juce::FontOptions (15.f)));
    trackNameLabel.setColour (juce::Label::textColourId, juce::Colours::white.darker (0.1));
    trackNameLabel.setJustificationType (juce::Justification::centred);

    // [Generated by Junie] Make the track name label editable on double-click.
    // This allows users to rename the track by double-clicking on the label.
    // Using setEditable(false, true, false) enables editing only on double-click, not single-click.
    trackNameLabel.setEditable (false, true, false);

    // Use I-beam cursor when hovering over the track name to indicate text editing
    trackNameLabel.setMouseCursor (juce::MouseCursor::IBeamCursor);

    setTrackType (TrackType::Instrument);
}

TrackHeaderComponent::~TrackHeaderComponent() = default;

void TrackHeaderComponent::setTrackName (juce::String name)
{
    trackNameLabel.setText (std::move (name), juce::dontSendNotification);
}

void TrackHeaderComponent::setTrackType (const TrackType type)
{
    if (type == TrackType::Drum)
    {
        setTrackName ("Drums");
    }
    else
    {
        setTrackName ("Instrument");
    }
}

bool TrackHeaderComponent::isMuted() const { return muteTrackButton.getToggleState(); }
void TrackHeaderComponent::setMuted (const bool shouldBeMuted)
{
    muteTrackButton.setToggleState (shouldBeMuted, juce::dontSendNotification);
}

bool TrackHeaderComponent::isSolo() const { return soloTrackButton.getToggleState(); }
void TrackHeaderComponent::setSolo (const bool shouldBeSolo)
{
    soloTrackButton.setToggleState (shouldBeSolo, juce::dontSendNotification);
}

bool TrackHeaderComponent::isArmed() const { return recordArmButton.getToggleState(); }
void TrackHeaderComponent::setArmed (const bool shouldBeArmed)
{
    recordArmButton.setToggleState (shouldBeArmed, juce::dontSendNotification);
}

void TrackHeaderComponent::setArmButtonEnabled (const bool enabled) { recordArmButton.setEnabled (enabled); }

void TrackHeaderComponent::setDimmed (const bool dim)
{
    setAlpha (dim ? 0.6f : 1.0f);
}

void TrackHeaderComponent::paint (juce::Graphics& g)
{
    auto bounds = getLocalBounds().toFloat().reduced (2.0f);

    g.setColour (juce::Colour (0xFF495057));

    // Rounded background
    const float radius = 10.0f;
    g.fillRoundedRectangle (bounds, radius);

    // Border
    g.setColour (juce::Colours::white.withAlpha (0.20f));
    g.drawRoundedRectangle (bounds, radius, 1.5f);
}

void TrackHeaderComponent::resized()
{
    juce::FlexBox fb;
    fb.flexDirection = juce::FlexBox::Direction::column;
    fb.justifyContent = juce::FlexBox::JustifyContent::flexStart;
    fb.alignItems = juce::FlexBox::AlignItems::stretch;

    const auto bounds = getLocalBounds().reduced (5);
    constexpr int buttonHeight = 25;
    const auto margin = juce::FlexItem::Margin (2, 0, 2, 0);

    fb.items.add (juce::FlexItem (trackNameLabel).withHeight (25.f));
    fb.items.add (juce::FlexItem (instrumentButton).withHeight (buttonHeight).withMargin (margin)); // <-- add this line
    fb.items.add (juce::FlexItem (settingsButton).withHeight (buttonHeight).withMargin (margin));
    fb.items.add (juce::FlexItem (muteTrackButton).withHeight (buttonHeight).withMargin (margin));
    fb.items.add (juce::FlexItem (soloTrackButton).withHeight (buttonHeight).withMargin (margin));
    fb.items.add (juce::FlexItem (recordArmButton).withHeight (buttonHeight).withMargin (margin));

    fb.performLayout (bounds);
}